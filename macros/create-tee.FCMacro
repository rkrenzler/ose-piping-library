# -*- coding: utf-8 -*-
# Author: Ruslan Krenzler.
# Date: 21 Januar 2018
# Create a tee-fitting.
# Version 0.3

import math
import csv
import os.path

from PySide import QtCore, QtGui
import FreeCAD
import Spreadsheet
import Sketcher
import Part


tu = FreeCAD.Units.parseQuantity
# This is the path to the dimensions table
CSV_TABLE_PATH = App.ConfigGet("UserAppData")+"tee.csv"


# The value RELATIVE_EPSILON is used to slightly change the size of a subtracted part
# to prevent problems with boolean operations.
# This value does not change the appearance of part and can be large.
# If the original value is L then we often use the value L*(1+RELATIVE_EPSILON) instead.
# The relative deviation is then (L*(1+RELATIVE_EPSILON)-L)/L = RELATIVE_EPSILON.
# That is why the constant has "relative" in its name.
# On my version of freecad 0.16 The macro works even with RELATIVE_EPSILON = 0.0.
# Maybe there is no more problems with boolean operations.
RELATIVE_EPSILON = 0.1

class CsvTable:
	""" Read coupling dimensions from a csv file"""
	def __init__(self):
		self.headers = []
		self.data = []
		self.hasValidData = False

	def load(self, filename):
		"""Load data from a CSV file."""
		self.hasValidData = False
		with open(filename, "r") as csvfile:
			csv_reader = csv.reader(csvfile, delimiter=',', quotechar='"')
			self.headers = csv_reader.next()
			# Fill the talble
			self.data = []
			names = []
			ni = self.headers.index("Name")
			for row in csv_reader:
				# Check if the name is unique
				name = row[ni]
				if name in names:
					print('Error: Not unique name "%s" found in %s'%(name, filename))
					exit(1)
				else:
					names.append(name)
				self.data.append(row)
			csvfile.close() # Should I close this file explicitely?
			self.hasValidData = self.hasNecessaryColumns()

	def hasNecessaryColumns(self):
		""" Check if the data contains all calumns required to create a coupling."""
		return all(h in self.headers for h in ["Name", "POD", "PID", "POD1", "PID1", "G", "G1", "G2", "H", "H1", "H2", "M", "M1"])

	def findPart(self, name):
		"""Return first first raw with the particular part name as a dictionary."""
		# First find out the index of the column "Name".
		ci = self.headers.index("Name")
		# Search for the first appereance of the name in this column.
		for row in self.data:
			if row[ci] == name:
				# Convert row to dicionary.
				return dict(zip(self.headers, row))
		return None

	def getPartName(self, index):
		"""Return part name of a row with the index *index*."""
		ci = self.headers.index("Name")
		return self.data[index][ci]

class Tee:
	def __init__(self, document):
		self.document = document
		# Fill data with test values
		self.G = tu("3 in")
		self.G1 = tu("3 in")
		self.G2 = tu("3 in")
		self.H = tu("4 in") # It is L/2 for symetrical Tee. Why extra dimension?
		self.H1 = tu("5 in")
		self.H2 = tu("6 in")
		self.PID = tu("2 in")
		self.PID1 = tu("1 in")
		self.POD = tu("3 in")
		self.POD1 = tu("2 in")
		self.M = tu("5 in")
		self.M1 = tu("4 in")

	@staticmethod
	def toSolid(document, part, name):
		"""Convert object to a solid.
			Basically those are commands, which FreeCAD runs when user converts a part to a solid.
		"""
		s = part.Shape.Faces
		s = Part.Solid(Part.Shell(s))
		o = document.addObject("Part::Feature", name)
		o.Label=name
		o.Shape=s
		return o
	@staticmethod
	def NestedObjects(group):
		res = []
		if group.OutList == []:
			res.append(group)
		else:
			# Append children first.
			for o in group.OutList:
				res += Tee.NestedObjects(o)
			res.append(group)
		return res

	def create(self, convertToSolid):
		L = self.H+self.H2
		vertical_outer_cylinder = self.document.addObject("Part::Cylinder","VerticalOuterCynlider")
		vertical_outer_cylinder.Radius = self.M1/2
		vertical_outer_cylinder.Height = self.H1
		vertical_inner_cylinder = self.document.addObject("Part::Cylinder","VerticalInnerCynlider")
		vertical_inner_cylinder.Radius = self.PID1/2
		vertical_inner_cylinder.Height =self.H1 * (1+RELATIVE_EPSILON)
		
		horizontal_outer_cylinder = self.document.addObject("Part::Cylinder","HorizontalOuterCynlider")
		horizontal_outer_cylinder.Radius = self.M/2
		horizontal_outer_cylinder.Height = L
		# I do not understand the logic here. Why when I use GUI the vector is App.Vector(0,0,-L/2)
		# and with the macros it is App.Vector(-L/2,0,0). Differne systems?
		horizontal_outer_cylinder.Placement = App.Placement(App.Vector(-self.H,0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
		horizontal_inner_cylinder = self.document.addObject("Part::Cylinder","HorizontalInnerCynlider")
		horizontal_inner_cylinder.Radius = self.PID/2
		horizontal_inner_cylinder.Height = L*(1+RELATIVE_EPSILON)
		horizontal_inner_cylinder.Placement = App.Placement(App.Vector(-self.H*(1+RELATIVE_EPSILON),0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
		
		# Fuse outer parts to a tee, fuse inner parts to a tee, substract both parts
		outer_fusion = self.document.addObject("Part::MultiFuse","OuterTeeFusion")
		outer_fusion.Shapes = [vertical_outer_cylinder,horizontal_outer_cylinder]
		inner_fusion = self.document.addObject("Part::MultiFuse","InnerTeeFusion")
		inner_fusion.Shapes = [vertical_inner_cylinder,horizontal_inner_cylinder]
		basic_tee = self.document.addObject("Part::Cut","Cut")
		basic_tee.Base = outer_fusion
		basic_tee.Tool = inner_fusion
		
		# Remove place for sockets.
		socket_left = self.document.addObject("Part::Cylinder","SocketLeft")
		socket_left.Radius = self.POD /2
		socket_left.Height = (self.H-self.G)*(1+RELATIVE_EPSILON)
		socket_left.Placement = App.Placement(App.Vector(-socket_left.Height - self.G,0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
#		socket_left.Placement = App.Placement(App.Vector(-(self.H-self.G),0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
		
		socket_right = self.document.addObject("Part::Cylinder","SocketRight")
		socket_right.Radius = self.POD /2
		socket_right.Height = (self.H2-self.G2)*(1+RELATIVE_EPSILON)
		socket_right.Placement = App.Placement(App.Vector(self.G2,0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
		
		socket_top = self.document.addObject("Part::Cylinder","SocketTop")
		socket_top.Radius = self.POD1 /2
		socket_top.Height = (self.H1 - self.G1)*(1+RELATIVE_EPSILON)
		socket_top.Placement = App.Placement(App.Vector(0,0,self.G1), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
		
		sockets_fusion = self.document.addObject("Part::MultiFuse","Sockets")
		sockets_fusion.Shapes = [socket_left,socket_right,socket_top]
		#document.recompute()
		# remove sockets from the basic tee
		tee = self.document.addObject("Part::Cut","Tee")
		tee.Base = basic_tee
		tee.Tool = sockets_fusion
		if convertToSolid:
			# Before making a solid, recompute documents. Otherwise there will be
			#    s = Part.Solid(Part.Shell(s))
			#    <class 'Part.OCCError'>: Shape is null
			# exception.
			self.document.recompute()
			# Now convert all parts to solid, and remove intermediate data.
			solid = self.toSolid(self.document, tee, "tee (solid)")
			# Remove previous (intermediate parts).
			parts = Tee.NestedObjects(tee)
			# Document.removeObjects can remove multple objects, when we use
			# parts directly. To prevent exceptions with deleted objects,
			# use the name list instead.
			names_to_remove = []
			for part in parts:
				if part.Name not in names_to_remove:
					names_to_remove.append(part.Name)
			for name in names_to_remove:
				print("Deleting temporary objects %s."%name)
				self.document.removeObject(name)
			return solid
		return tee

class TeeFromTable:
	"""Create a part with dimensions from a CSV table."""
	def __init__ (self, document, table):
		self.document = document
		self.table = table
	def create(self, partName, convertToSolid = True):
		tee = Tee(self.document)
		row = self.table.findPart(partName)
		if row is None:
			print("Part not found")
			return
		tee.G = tu(row["G"])
		tee.G1 = tu(row["G1"])
		tee.G2 = tu(row["G2"])
		tee.H = tu(row["H"]) # It is L/2 for symetrical Tee. Why extra dimension?
		tee.H1 = tu(row["H1"])
		tee.H2 = tu(row["H2"])
		tee.PID = tu(row["PID"])
		tee.PID1 = tu(row["PID1"])
		tee.POD = tu(row["POD"])
		tee.POD1 = tu(row["POD1"])
		tee.M = tu(row["M"])
		tee.M1 = tu(row["M1"])

		part = tee.create(convertToSolid)
		part.Label = partName
		return part


# Before working with macros, try to load the dimension table.

# Check if the CSV file exists.
if os.path.isfile(CSV_TABLE_PATH) == False:
	text = "This macro requires %s  but this file does not exist."%(CSV_TABLE_PATH)
	msgBox = QtGui.QMessageBox(QtGui.QMessageBox.Warning, "Creating of the coupling failed.", text)
	msgBox.exec_()
	exit(1) # Error

print("Trying to load CSV file with dimensions: %s"%CSV_TABLE_PATH) 
table = CsvTable()
table.load(CSV_TABLE_PATH)

if table.hasValidData == False:
	text = 'Invalid %s.\n'\
		'It must contain columns "Name", "POD", "PID", "POD1", "PID1", "G", "G1", "G2", "H", "H1", "H2", "M" and "M1".'%(CSV_TABLE_PATH)
	msgBox = QtGui.QMessageBox(QtGui.QMessageBox.Warning, "Creating of the tee failed.", text)
	msgBox.exec_()
	exit(1) # Error
	
# determine an active document
document = App.activeDocument()

# Test macros.
def TestTee():
	tee = Tee(document)
	tee.create(False)
	document.recompute()
def TestTable():
	tee = TeeFromTable(document, table)
	for i in range(0, len(table.data)):
		print("Selecting row %d"%i)
		partName = table.getPartName(i)
		print("Creating part %s"%partName)
		part = tee.create(partName, True)
		document.recompute()
	document.recompute()
# Create tee fitting.
TestTable()


